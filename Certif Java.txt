
-----------------switch/case
int and Integer 
short and Short
byte and Byte 

String 
char and Character 

enum values 

	X long car ne peut les transformer en int
	X float, double		imprécis
	X boolean


---------------StringBuilder
sb.append(char[], firstIndexInclus, nbDeCharAjoutés);
sb.append("maString", firstIndexInclus, lastIdexExclus);
sb.charAt(index);

sb.deleteCharAt(index);
sb.delete(startIndex, lastIndexExclus);

sb.insert(index, char[]/string);

sb.replace(firstIndex, lastIndexExclus, char[]/str);
	supprime les char entre les index first et last exclu, et remplace par toute la string (même si plus longue)
	si lastIndexExclus plus grnad que la chaine de base => supprime les char jusqu'à la fin et remplace par la nouvelle chaine
	si firstIndex = lastIndexExclus alors insertion à cet index de la chaine

String substring = sb.subString(firstIndex, lastIndexExlus);
	ne modifie pas l'objet sb lui-même !



------------java.util.Date
Date()
Date(year, month, date)
Date(year, month, date, hrs, min, sec)
Date(long)	long=timestamp=nbs milisec depuis 01/01/70 00:00:00


date.after(otherDate)	=> true ou false
date.before(otherDate)

date.getTime()		=> retourne long timestamp


------------------Initialisation
{1, 2, 3} ne peut servir que lors d'une initialisation de variable !



------------------Array

ArrayList utilise un tableau. Par défaut, ce tableau à une taille de 10.



---------------Héritage

redéfinition de méthode : private -> defaut (package) -> protected -> public

Dabord static{   }, puis {  }, puis constructeur de la classe mère puis de la classe fille




-------------Exception et RuntimeException

RuntimeException hérite de Exception

RuntimeException = Unchecked Exception = exception levée lors du traitement et pouvant être capturée, crash le prog sinon.

Exception = exception levée au moment de la compilation et qui arrète la compilation.



Les Exception = Checked Exception doivent être toujours renvoyées au niveau suivant

Les RuntimeException = Unchecked Exception sont transmise à l'élément parent automatiquement jusqu'à ce qu'elles soient capturées.

Exemple :
void maMethodeExc() throws Exception {
}

void maMethodeRunExc() throws RuntimeException {
}

void maMethodeDAppel() throws Exception {
   maMethodeExc();
}

void maMethodeDAppel() {
   maMethodeRunExc();
}






ATTENTION : IOException n'est pas RuntimeException !


------------dans un constructeur :
soit super(), soit this(), mais pas les 2 !
Car chacun doit être placé sur la 1re ligne du constructeur.

-------------en cas de redéfinition de méthode
modifieur identique ou plus large !


-------------La classe String est immutable
	=> maString.replace('A', 'B') 			ne fait rien
	=> maString = maString.replace('A', 'B')	remplace bien les A par B

str += "ajout";	=> création d'une nouvelle chaine qui concatène les 2, puis affectation de cette chaine à la variable str.
Contrairement à StringBuilder = String de taille variable !
(semblable à Array et ArrayList)

------------monPackage.*
monPackage.* n'importe que les classes dans le package, mais pas les sous-packages !.



-----------




