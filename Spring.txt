

Annotations
Identification des beans
@Component	générique pour identifier un composant géré par Spring
@Service	identifie les beans contanant le code métier (nécéssitant une ou plusieurs injections)
@Repository	identifie les beans liés à la persistence des données (DB, ...)
@Controller	identifi les points d'entrées de l'appli

   @Primary	à ajouter après l'une des annotations précédentes pour définir le bean à utiliser par défaut en cas de création de plusieurs beans de même type
		ou ajout d'un identifiant
			Rq: par défaut, l'identifiant = le nom de la classe avec la première lettre en minuscule.

@Service
@Primary
public class FixedMeasure implements Measure {

@Service
public class VariableMeasure implements Measure {


@Service("fixedMeasure")
public class FixedMeasure implements Measure {

@Service("variableMeasure")
public class VariableMeasure implements Measure {




@Configuration	identifie les classe ApplicationConfig (= Factory) qui vont gérer les beans (injection à la demande, persistance, ...)
@ComponentScan	autoscan des éléments de l'appli afin de répérer automatiquement les Beans sans avoir à les déclarer dans la Factory
		ATTENTION : ne scane que les classe contenue dans le même package (et sous-packages) que la classe ApplicationConfig
@ComponentScan("com.monapp.monpackage")		scanne les classes du package et sous-package indiqué


@ComponentScan
@Comfiguration
public class MonApplicationConfig {
}

@ComponentScan("com.monapp.monpackage")
@Comfiguration
public class MonApplicationConfig {
}

ApplicationContext	objet servant à obtenir les bean manuellements
ApplicationContext context = new AnnotationConfigApplicationContext(MonApplicationConfig.class);
MaClasseService maClasseService = context.getBean(MaClasseService.class);


@Autowired	permet d'injecter un bean géré par Spring dans une classe @Component
		Rq: recheche le bean à injecter d'abord par type, puis par nom (identifiant)
		Rq: @Autowired est facultatif pour l'injection par constructeur à condition qu'il n'existe qu'un seul constructeur !
	NoSuchBeanDefinitionException = bean non trouvé
	NoUniqueBeanDefinitionException = plusieurs bean peuvent correspondre au type demandé
@Autowired(requires = "false")	injection facultative (si la classe bean n'est pas trouvée, injecte null et ne retourne pas l'erreur NoSuchBeanDefinitionException)

   @Qualifier("   ")	définit le bean à utiliser via son identifiant en cas d'ambiguité (si plusieurs beans sont possibles car de mêmes types => voir @Primay)

@Ressource	équivalente à @Autowired, mais effectu la recherche du bean à injecter d'abord par nom, puis pas type.

Injection par setter :
@Component
public class MaClasseImpl implements MonInterfaceService {
   @Autowired
   private MonAutreClasseImpl maci;
}

@Component
public class MaClasseImpl implements MonInterfaceService {
   private MonAutreClasseImpl maci;

   @Autowired
   public void setMonAutreClasseImpl(MonAutreClasseImpl maci) {
      this.maci = maci;
}


Injection par constructeur :
@Component
public class MaClasseImpl implements MonInterfaceService {
   private MonAutreClasseImpl maci;

   @Autowired
   public MaClasseImpl(MonAutreClasseImpl maci) {
      this.maci = maci;
}




Injection par setter :
@Component
public class MaClasseImpl implements MonInterfaceService {
   @Autowired
   @Qualifier("maciA")
   private MonAutreClasseImpl maciA;
}

Injection par constructeur :
@Component
public class MaClasseImpl implements MonInterfaceService {
   private MonAutreClasseImpl maci;

   @Autowired
   public MaClasseImpl(@Qualifier("maciB") MonAutreClasseImpl maciB) {
      this.maci = maci;
}


options :
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)		définit le scope
.SINGLETON		(défaut) une seule instance pour toute l'appli
.SCOPE_PROTOTYPE	une instance à chaque injection
.REQUEST		une instance par requete
.SESSION		une instance par session utilisateur (dépréciée)
.APPLICATION		une instance par application
.WEBSOCKET		une instance par socket

@Lazy			instancié et injecté uniquement lorsque il y en a besoin => allège le lancement de l'appli
			(par défaut, tout est instancié à l'ouverture de l'appli)

@Service
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Lazy
public class MaClasseService {
}


---------------------------------------------------------------------------
Ressource

ResourceLoader		bean de Spring qui permet d'accéder aux ressource (classpath, file, url)
   .getRessource(   )	selectionne le type de ressource et son adresse

ressourceLoader.getRessource("classpath:monFichier.txt");
ressourceLoader.getRessource("file:///C:/monChemin/monFichier.txt");	ATTENTION : ///C:/ nécéssaire qu'avec Windows
ressourceLoader.getRessource("url:https://www.monsite.com");


@Component
public class MaClasseService {
   @Autowired
   private RessourceLoader ressourceLoader;

   public void readFile() {
      try {
         Ressource ressource = ressourceLoader.getRessource("file:///C:/monChemin/monFichier.txt");
         InputStream stream = resource.getInputStream();
         Scanner scanner = new Scanner(stream).useDelimiter("\\n");
         while (scanner.hasNext()) {
            System.out.println(scanner.next());
      }catch (IOException e) {
      }
   }
}
      


Fichier de configuration

monFichierConfig.properties	fichier de config dans src/main/ressources

myapp.name=BigCorp application
myapp.version=1
myapp.emails=contact-dev@bigcorp.com,test@bigcorp.com		=> List ou Set
myapp.baseuri=${BASE_URI:http://localhost:8080}			=> valeur de la variable environement, si absente valeur par défaut


Propriétés

@PropertySource(   )		charge le fichier .properties indiqué en paramètre
			FileNotFoundException
@PropertySource("classpath:monFichierConfig.properties")
	Sans lever d'exception en cas de fichier non trouvé :
@PropertySource(value = "classpath:monFichierConfig.properties" ignoreRessourceNotFound=true)

@Value(   )		récupère la valeur de la propriété dans le fichier

@Value("${myapp.name}")
private String name

@Value("${myapp.version}")
private Integer version

@Value("${myapp.name}")
private Set<String> emails;



Profils

@Profil(   )		défini le profil pour lequel la classe de configuration (ApplicationConfig) ou le bean va être utilisé
			ATTENTION : si elle est utilisée sur la classe, @Autoscan ne doit pas être appliquée car il ne peut être utilisé qu'une seule fois : sur la classe ApplicationConfig générale

@ComponentScan
@Comfiguration
public class monApplicationConfig {
}

@Configuration
@Profile("!prod") //ou @Profile("default")
public class monApplicationConfig {
}

@Configuration
@Profile("prod")
public class monApplicationConfig {
}

Activation du profil :
 ° via la variable d'environnement de Spring
Edit Configurations > Environment variables
 -> spring.profiles.active=prod			manuellement

-Dspring.profies.active="prod, cloud"		en ligne de commande
		
.setActiveProfiles(   )		utilisation d'un profil via l'ApplicationContext

AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
context.getEnvironment().setActiveProfiles("dev", "cloud");
context.register(BigCorpApplicationConfig.class);
context.refresh();



Environnement

Environment

@Component
public class MaClasseService {
   @Autowired
   private Environment environment;

   public ApplicationInfo applicationInfo() {
      String name = environment.getRequiredProperty("myapp.name");
      Integer version = environment.getRequiredProperty("myapp.version", Integer.class);
      Set<String> emails = environment.getRequiredProperty("myapp.emails", Set.class);
      String javaHome = environment.getRequirdProperty("JAVA_HOME");

      return new ApplicationInfo(name, version, emails);
   }
}



----------------------------------------------------------AOP

AOP = Aspect-Oriented Programming
permet de surcharger une méthode en ajoutant des comportements
Pour cela, on localise les méthodes à modifier (= les join points) (plusieurs join points = point cut)
on défini le code à rajouter avant et/ou après le résultat de cette méthode (les Advice)
L'ensemble est appelé : Aspect

On peut recréer ce comportement manuellement :
public class ComputerProxy extends Computer {
   public int add(int a, int b) {
      System.out.println("DEBUT Appel de la méthode add");
      int result = super.add(a, b);
      System.out.println("FIN Appel de la méthode add : " + result)
      return result;
   }
}

ATTENTION : ne doit être appliqué que sur des classe implémentant une interface ! Sinon rend la déclaration plus complexe.

	
compile "org.springframework:spring-aop:${springVersion}	dépendances à ajouter dans build.gradle
compile "org.aspectj:aspectjweaver:1.8.13"			AspectJ est l'implémentation de référence, mais Spring AOP (qui se base sur les bibliothèques AscpectJ) est plus simple à utiliser


	indiquer de gérer également l'AOP
@Configuration
@EnableAspectJAutoProxy				
public class MonApplicationConfig {
}

	Définir une nouvelle annotation spécifique pour chaque AOP
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MonAnnotationAOP { }


	Annoter les méthodes concernées avec l'annotation
@Service
public class MaClasseServiceImpl implements MaClasseService {
   @MonAnnotationAOP
   @Override
   public String maMethode(String monParametre) {
   }
}

	Définir l'Advice
@Component
@Aspect
public class MonAnnotationAOPAspect {

   @Before("@annotation(MonAnnotationAOP)")
   public void logServiceBeforeCall(JoinPoint jp) {
      System.out.println("Le bean concerné par l'Aspect est : " + jp.target());
      System.out.println("Appel de la méthode " + jp.getSignature());
      System.out.println("avec les agruments :" + jp.args());
   }

   @Around("@annotation(com.training.spring.bigcorp.config.Secure)")		//permet de choisir si la méthode est exécutée ou non !
   public Object doCheckSecurity(ProceedingJoinPoint pjp) throws Throwable Object returnedValue;
      CurrentUser user = applicationContext.getBean(CurrentUser.class);
      if(securityService.checkAccess(user)){
      return pjp.proceed();
   }
      throw new ForbiddenTargetException("User not allowed to use " + "this feature");
   }


   @AfterReturning(pointcut = "@annotation(MonAnnotationAOP)", returning = "element")	//exécuté seulement si la méthode n'a pas levé d'exception
   public void logServiceAfterCall(JoinPoint jp, Object element) {
      if (element == null) {
         System.out.println("Finder " + jp.getTarget() + "returns null";
      } else {
         System.out.println("Finder " + jp.getTarget() + "returns "+ element.toString());
   }

   @AfterThrowing(pointcut = "@annotation(Finder)", throwing = "ex")	//exécuté seulement si la méthode a retourné une exception
   public void logServiceAfterException(RuntimeException ex) {
      System.out.println("Error " + ex.getMessage());
   }

   @After("@annotation(MonAnnotationAOP) && args(monParametre)")	//exécuté après la méthode, qu'il y ait eu exception ou non
   public void logServiceBeforeCall(JoinPoint jp, String monParametre) {
      System.out.println("Le paramètre qui a été utilisé par la méthode était : " + monParametre);
   }

   
}


----------------------------------------------------Boot
Spring Boot = projet qui embarque avec lui un server pour être déployé automatiquement dans le cloud
Utilise : framework Spring 5, Java 8, Tomcat 8.5 par défaut (compatible Jetty 9.4, Undertow 3.1)

Nouveau projet	Démarer un projet sur https://start.spring.io/ (avec les dépendances Spring Web Starter, Spring Boot Devtools) puis ouvrir le projet avec l'option auto-import sur InteliJ

@SpringBootApplication		méta-annotation remplacent @Configuration + @ComponentScan + @EnableAutoConfiguration + @EnableConfigurationProperties
				=> autoscan Spring sur tout le projet pour gérer l'injection des Beans, permettre l'auto-configuration, permet de récupérer les valeurs des propriétés dans les fichiers applications.properties et de les injecter dans les Beans dédiés annotés avec @ConfigurationProperties(prefix = "...")


@SpringBootApplication
@EnableConfigurationProperties
public class MonApplication {
   public static void main(String[] args) {
   }
}


application.properties		fichier contenu dans src/main/resources/ chargé automatiquement (inutile d'utiliser @PropertySource) quelque soit le profil
application-default.properties
application-prod.properties	fichiers contenant les valeurs des propriétés spécifiques à chaque profil et venant surcharger les propriétés par défaut si le profil est activé
application-cloud.properties


gradlew clean assemble		crée le fichier .jar dans build/libs/ si tous les tests unitaires sont passants
java -jar build/libs/monProjet-0.0.1-SNAPSHOT.jar	lanche l'appli sur le serveur

gradlew --continuous bootRun	lance l'appli sur le serveur en continue (prenant en compte les modif en temps réels)
				(ctrl+C pour l'arréter)


-----Tests


@RunWith(SpringRunner.class)	à placer sur les classes Test afin d'indiquer que le test est géré par Spring et JUnit
@SpringBootTest			à placer sur les classes Test afin de créer un application context spécifique au test

@RunWith(SpringRunner.class)
@SpringBootTest
public class MaClasseTest {
   @Test
   public void testMaMehtode() {
   }
}


-----Logs
Spring Boot integre SLF4J et LogBack pour gérer les logs
Simplement besoin de définir les niveaux dans application.properties et d'appeller le LOGGER dans la classe

application.properties
logging.file=c:/data/logs/monappli.log		=> fichier de sortie des Logs
logging.level.root=INFO;			=> niveau de Log par défaut
logging.level.monpackage=ERROR			=> niveau de log spécifique aux classes d'un package et de ses sous-packages
logging.level.monpackage.monsouspackage=DEBUG

logback.xml		il est toujours possible de définir les propriétés des logs dans src/main/resources/logback.xml, utile notamment pour les system plus complexe de rolling
<configuration>
   <include resource="org/springframework/boot/logging/logback/base.xml"/> (1)
   <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"> (2)
      <file>/data/logs/bigcorp.log</file>
      <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
         <FileNamePattern>/data/logs/bigcorp/recovery.%d{yyyy-MM-dd}.%i.zip</FileNamePattern>
         <maxFileSize>32MB</maxFileSize>
         <maxHistory>15</maxHistory>
         <totalSizeCap>500MB</totalSizeCap>
      </rollingPolicy>
      <encoder>
         <pattern>${CONSOLE_LOG_PATTERN}</pattern> (3)
      </encoder>
   </appender>
   <logger name="com.training.spring.bigcorp" level="DEBUG" additivity="false"> (4)
      <appender-ref ref="FILE"/>
      <appender-ref ref="CONSOLE"/>
     </logger>
   <root level="INFO"> (5)
      <appender-ref ref="FILE" />
   </root>
</configuration>

(1) inclusion de la configuration de Spring Boot (permet d'avoir accés au logger de base CONSOLE) (3)
(4) possibilité de définir plusieurs niveau par logger
(5) root level = niveau de log par défaut
(3) rolling, 32 Mo par fichier max, 15 fichiers max, 500 Mo max pour la taille de tous les fichiers réunis


@Service
public class MaClasseImpl implements MaClasse {
   private final static Logger LOGGER = LoggerFactory.getLogger(MaClasseImpl.class);

   public void maMethode(String maString) {
      LOGGER.info("Appel de maMethode avec argument {}", maString);
      ...
   }
}


----Propriétés
Chagement des fichiers application.properties automatique
ces fichiers peuvent se placer à différents endroits, mais selon leur emplacement, ils n'ont pas la même priorité :
1. `file:./config/`   <- emplacement + prioritaire
2. `file:./`
3. `classpath:/config/`
4. `classpath:/`	<- emplacement - prioritaire


@ConfigurationProperties(prefix = "monappli")		permet de récupérer automatiquement les valeurs des propriétés et de les placer dans un bean sans avoir à utiliser @Autowired Environment ni @Value("${monappli.mapropriete}")
							ATTENTION : pour les classes Test, ne fonctionne que si la classe principale (contenant la méthode main) est annotée avec @EnableConfigurationProperties !

application.properties :
monappli.name=Mon nom
monappli.version=1.0.0
monappli.emails=contact@bigcorp.com, test@bigcorp.com
monappli.sousgroupe.measure-fixe=10
monappli.sousgroupe.measure-variable=20

							
@Component
@ConfigurationProperties(prefix = "monappli")
public class MonAppliProperties {
   private String name;
   private int version;
   private Set<String> emails;

   @NestedConfigurationProperty
   private MonSousGroupeDeProprietes sousgroupe;

   // getter et setter
}
		//@Nested identifie la classe automatiquement sans avoir besoin de l'annoter avec @Component
public class MonSousGroupeDeProprietes {
   private int measureFixe;
   private int measureVariable;
   
   //getter et setter
}


----------------------------------------JPA






























