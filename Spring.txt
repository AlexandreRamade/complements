

Annotations
Identification des beans
@Component	générique pour identifier un composant géré par Spring
@Service	identifie les beans contanant le code métier (nécéssitant une ou plusieurs injections)
@Repository	identifie les beans liés à la persistence des données (DB, ...)
@Controller	identifi les points d'entrées de l'appli

   @Primary	à ajouter après l'une des annotations précédentes pour définir le bean à utiliser par défaut en cas de création de plusieurs beans de même type
		ou ajout d'un identifiant
			Rq: par défaut, l'identifiant = le nom de la classe avec la première lettre en minuscule.

@Service
@Primary
public class FixedMeasure implements Measure {

@Service
public class VariableMeasure implements Measure {


@Service("fixedMeasure")
public class FixedMeasure implements Measure {

@Service("variableMeasure")
public class VariableMeasure implements Measure {




@Configuration	identifie les classe ApplicationConfig (= Factory) qui vont gérer les beans (injection à la demande, persistance, ...)
@ComponentScan	autoscan des éléments de l'appli afin de répérer automatiquement les Beans sans avoir à les déclarer dans la Factory
		ATTENTION : ne scane que les classe contenue dans le même package (et sous-packages) que la classe ApplicationConfig
@ComponentScan("com.monapp.monpackage")		scanne les classes du package et sous-package indiqué


@ComponentScan
@Comfiguration
public class MonApplicationConfig {
}

@ComponentScan("com.monapp.monpackage")
@Comfiguration
public class MonApplicationConfig {
}

ApplicationContext	objet servant à obtenir les bean manuellements
ApplicationContext context = new AnnotationConfigApplicationContext(MonApplicationConfig.class);
MaClasseService maClasseService = context.getBean(MaClasseService.class);


@Autowired	permet d'injecter un bean géré par Spring dans une classe @Component
		Rq: recheche le bean à injecter d'abord par type, puis par nom (identifiant)
		Rq: @Autowired est facultatif pour l'injection par constructeur à condition qu'il n'existe qu'un seul constructeur !
	NoSuchBeanDefinitionException = bean non trouvé
	NoUniqueBeanDefinitionException = plusieurs bean peuvent correspondre au type demandé
@Autowired(requires = "false")	injection facultative (si la classe bean n'est pas trouvée, injecte null et ne retourne pas l'erreur NoSuchBeanDefinitionException)

   @Qualifier("   ")	définit le bean à utiliser via son identifiant en cas d'ambiguité (si plusieurs beans sont possibles car de mêmes types => voir @Primay)

@Ressource	équivalente à @Autowired, mais effectu la recherche du bean à injecter d'abord par nom, puis pas type.

Injection par setter :
@Component
public class MaClasseImpl implements MonInterfaceService {
   @Autowired
   private MonAutreClasseImpl maci;
}

@Component
public class MaClasseImpl implements MonInterfaceService {
   private MonAutreClasseImpl maci;

   @Autowired
   public void setMonAutreClasseImpl(MonAutreClasseImpl maci) {
      this.maci = maci;
}


Injection par constructeur :
@Component
public class MaClasseImpl implements MonInterfaceService {
   private MonAutreClasseImpl maci;

   @Autowired
   public MaClasseImpl(MonAutreClasseImpl maci) {
      this.maci = maci;
}




Injection par setter :
@Component
public class MaClasseImpl implements MonInterfaceService {
   @Autowired
   @Qualifier("maciA")
   private MonAutreClasseImpl maciA;
}

Injection par constructeur :
@Component
public class MaClasseImpl implements MonInterfaceService {
   private MonAutreClasseImpl maci;

   @Autowired
   public MaClasseImpl(@Qualifier("maciB") MonAutreClasseImpl maciB) {
      this.maci = maci;
}


options :
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)		définit le scope
.SINGLETON		(défaut) une seule instance pour toute l'appli
.SCOPE_PROTOTYPE	une instance à chaque injection
.REQUEST		une instance par requete
.SESSION		une instance par session utilisateur (dépréciée)
.APPLICATION		une instance par application
.WEBSOCKET		une instance par socket

@Lazy			instancié et injecté uniquement lorsque il y en a besoin => allège le lancement de l'appli
			(par défaut, tout est instancié à l'ouverture de l'appli)

@Service
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Lazy
public class MaClasseService {
}


---------------------------------------------------------------------------
Ressource

ResourceLoader		bean de Spring qui permet d'accéder aux ressource (classpath, file, url)
   .getRessource(   )	selectionne le type de ressource et son adresse

ressourceLoader.getRessource("classpath:monFichier.txt");
ressourceLoader.getRessource("file:///C:/monChemin/monFichier.txt");	ATTENTION : ///C:/ nécéssaire qu'avec Windows
ressourceLoader.getRessource("url:https://www.monsite.com");


@Component
public class MaClasseService {
   @Autowired
   private RessourceLoader ressourceLoader;

   public void readFile() {
      try {
         Ressource ressource = ressourceLoader.getRessource("file:///C:/monChemin/monFichier.txt");
         InputStream stream = resource.getInputStream();
         Scanner scanner = new Scanner(stream).useDelimiter("\\n");
         while (scanner.hasNext()) {
            System.out.println(scanner.next());
      }catch (IOException e) {
      }
   }
}
      


Fichier de configuration

monFichierConfig.properties	fichier de config dans src/main/ressources

myapp.name=BigCorp application
myapp.version=1
myapp.emails=contact-dev@bigcorp.com,test@bigcorp.com		=> List ou Set
myapp.baseuri=${BASE_URI:http://localhost:8080}			=> valeur de la variable environement, si absente valeur par défaut


Propriétés

@PropertySource(   )		charge le fichier .properties indiqué en paramètre
			FileNotFoundException
@PropertySource("classpath:monFichierConfig.properties")
	Sans lever d'exception en cas de fichier non trouvé :
@PropertySource(value = "classpath:monFichierConfig.properties" ignoreRessourceNotFound=true)

@Value(   )		récupère la valeur de la propriété dans le fichier

@Value("${myapp.name}")
private String name

@Value("${myapp.version}")
private Integer version

@Value("${myapp.name}")
private Set<String> emails;



Profils

@Profil(   )		défini le profil pour lequel la classe de configuration (ApplicationConfig) ou le bean va être utilisé
			ATTENTION : si elle est utilisée sur la classe, @Autoscan ne doit pas être appliquée car il ne peut être utilisé qu'une seule fois : sur la classe ApplicationConfig générale

@ComponentScan
@Comfiguration
public class monApplicationConfig {
}

@Configuration
@Profile("!prod") //ou @Profile("default")
public class monApplicationConfig {
}

@Configuration
@Profile("prod")
public class monApplicationConfig {
}

Activation du profil :
 ° via la variable d'environnement de Spring
Edit Configurations > Environment variables
 -> spring.profiles.active=prod			manuellement

-Dspring.profies.active="prod, cloud"		en ligne de commande
		
.setActiveProfiles(   )		utilisation d'un profil via l'ApplicationContext

AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();
context.getEnvironment().setActiveProfiles("dev", "cloud");
context.register(BigCorpApplicationConfig.class);
context.refresh();



Environnement

Environment

@Component
public class MaClasseService {
   @Autowired
   private Environment environment;

   public ApplicationInfo applicationInfo() {
      String name = environment.getRequiredProperty("myapp.name");
      Integer version = environment.getRequiredProperty("myapp.version", Integer.class);
      Set<String> emails = environment.getRequiredProperty("myapp.emails", Set.class);
      String javaHome = environment.getRequirdProperty("JAVA_HOME");

      return new ApplicationInfo(name, version, emails);
   }
}



----------------------------------------------------------AOP

AOP = Aspect-Oriented Programming
permet de surcharger une méthode en ajoutant des comportements
Pour cela, on localise les méthodes à modifier (= les join points) (plusieurs join points = point cut)
on défini le code à rajouter avant et/ou après le résultat de cette méthode (les Advice)
L'ensemble est appelé : Aspect

On peut recréer ce comportement manuellement :
public class ComputerProxy extends Computer {
   public int add(int a, int b) {
      System.out.println("DEBUT Appel de la méthode add");
      int result = super.add(a, b);
      System.out.println("FIN Appel de la méthode add : " + result)
      return result;
   }
}

ATTENTION : ne doit être appliqué que sur des classe implémentant une interface ! Sinon rend la déclaration plus complexe.

	
compile "org.springframework:spring-aop:${springVersion}	dépendances à ajouter dans build.gradle
compile "org.aspectj:aspectjweaver:1.8.13"			AspectJ est l'implémentation de référence, mais Spring AOP (qui se base sur les bibliothèques AscpectJ) est plus simple à utiliser


	indiquer de gérer également l'AOP
@Configuration
@EnableAspectJAutoProxy				
public class MonApplicationConfig {
}

	Définir une nouvelle annotation spécifique pour chaque AOP
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface MonAnnotationAOP { }


	Annoter les méthodes concernées avec l'annotation
@Service
public class MaClasseServiceImpl implements MaClasseService {
   @MonAnnotationAOP
   @Override
   public String maMethode(String monParametre) {
   }
}

	Définir l'Advice
@Component
@Aspect
public class MonAnnotationAOPAspect {

   @Before("@annotation(MonAnnotationAOP)")
   public void logServiceBeforeCall(JoinPoint jp) {
      System.out.println("Le bean concerné par l'Aspect est : " + jp.target());
      System.out.println("Appel de la méthode " + jp.getSignature());
      System.out.println("avec les agruments :" + jp.args());
   }

   @Around("@annotation(com.training.spring.bigcorp.config.Secure)")		//permet de choisir si la méthode est exécutée ou non !
   public Object doCheckSecurity(ProceedingJoinPoint pjp) throws Throwable Object returnedValue;
      CurrentUser user = applicationContext.getBean(CurrentUser.class);
      if(securityService.checkAccess(user)){
      return pjp.proceed();
   }
      throw new ForbiddenTargetException("User not allowed to use " + "this feature");
   }


   @AfterReturning(pointcut = "@annotation(MonAnnotationAOP)", returning = "element")	//exécuté seulement si la méthode n'a pas levé d'exception
   public void logServiceAfterCall(JoinPoint jp, Object element) {
      if (element == null) {
         System.out.println("Finder " + jp.getTarget() + "returns null";
      } else {
         System.out.println("Finder " + jp.getTarget() + "returns "+ element.toString());
   }

   @AfterThrowing(pointcut = "@annotation(Finder)", throwing = "ex")	//exécuté seulement si la méthode a retourné une exception
   public void logServiceAfterException(RuntimeException ex) {
      System.out.println("Error " + ex.getMessage());
   }

   @After("@annotation(MonAnnotationAOP) && args(monParametre)")	//exécuté après la méthode, qu'il y ait eu exception ou non
   public void logServiceBeforeCall(JoinPoint jp, String monParametre) {
      System.out.println("Le paramètre qui a été utilisé par la méthode était : " + monParametre);
   }

   
}


----------------------------------------------------Boot
Spring Boot = projet qui embarque avec lui un server pour être déployé automatiquement dans le cloud
Utilise : framework Spring 5, Java 8, Tomcat 8.5 par défaut (compatible Jetty 9.4, Undertow 3.1)

Nouveau projet	Démarer un projet sur https://start.spring.io/ (avec les dépendances Spring Web Starter, Spring Boot Devtools) puis ouvrir le projet avec l'option auto-import sur InteliJ

@SpringBootApplication		méta-annotation remplacent @Configuration + @ComponentScan + @EnableAutoConfiguration + @EnableConfigurationProperties
				=> autoscan Spring sur tout le projet pour gérer l'injection des Beans, permettre l'auto-configuration, permet de récupérer les valeurs des propriétés dans les fichiers applications.properties et de les injecter dans les Beans dédiés annotés avec @ConfigurationProperties(prefix = "...")


@SpringBootApplication
@EnableConfigurationProperties
public class MonApplication {
   public static void main(String[] args) {
   }
}


application.properties		fichier contenu dans src/main/resources/ chargé automatiquement (inutile d'utiliser @PropertySource) quelque soit le profil
application-default.properties
application-prod.properties	fichiers contenant les valeurs des propriétés spécifiques à chaque profil et venant surcharger les propriétés par défaut si le profil est activé
application-cloud.properties


gradlew clean assemble		crée le fichier .jar dans build/libs/ si tous les tests unitaires sont passants
java -jar build/libs/monProjet-0.0.1-SNAPSHOT.jar	lanche l'appli sur le serveur

gradlew --continuous bootRun	lance l'appli sur le serveur en continue (prenant en compte les modif en temps réels)
				(ctrl+C pour l'arréter)


-----Tests


@RunWith(SpringRunner.class)	à placer sur les classes Test afin d'indiquer que le test est géré par Spring et JUnit
@SpringBootTest			à placer sur les classes Test afin de créer un application context spécifique au test

@RunWith(SpringRunner.class)
@SpringBootTest
public class MaClasseTest {
   @Test
   public void testMaMehtode() {
   }
}


-----Logs
Spring Boot integre SLF4J et LogBack pour gérer les logs
Simplement besoin de définir les niveaux dans application.properties et d'appeller le LOGGER dans la classe

application.properties
logging.file=c:/data/logs/monappli.log		=> fichier de sortie des Logs
logging.level.root=INFO;			=> niveau de Log par défaut
logging.level.monpackage=ERROR			=> niveau de log spécifique aux classes d'un package et de ses sous-packages
logging.level.monpackage.monsouspackage=DEBUG

logback.xml		il est toujours possible de définir les propriétés des logs dans src/main/resources/logback.xml, utile notamment pour les system plus complexe de rolling
<configuration>
   <include resource="org/springframework/boot/logging/logback/base.xml"/> (1)
   <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"> (2)
      <file>/data/logs/bigcorp.log</file>
      <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
         <FileNamePattern>/data/logs/bigcorp/recovery.%d{yyyy-MM-dd}.%i.zip</FileNamePattern>
         <maxFileSize>32MB</maxFileSize>
         <maxHistory>15</maxHistory>
         <totalSizeCap>500MB</totalSizeCap>
      </rollingPolicy>
      <encoder>
         <pattern>${CONSOLE_LOG_PATTERN}</pattern> (3)
      </encoder>
   </appender>
   <logger name="com.training.spring.bigcorp" level="DEBUG" additivity="false"> (4)
      <appender-ref ref="FILE"/>
      <appender-ref ref="CONSOLE"/>
     </logger>
   <root level="INFO"> (5)
      <appender-ref ref="FILE" />
   </root>
</configuration>

(1) inclusion de la configuration de Spring Boot (permet d'avoir accés au logger de base CONSOLE) (3)
(4) possibilité de définir plusieurs niveau par logger
(5) root level = niveau de log par défaut
(3) rolling, 32 Mo par fichier max, 15 fichiers max, 500 Mo max pour la taille de tous les fichiers réunis


@Service
public class MaClasseImpl implements MaClasse {
   private final static Logger LOGGER = LoggerFactory.getLogger(MaClasseImpl.class);

   public void maMethode(String maString) {
      LOGGER.info("Appel de maMethode avec argument {}", maString);
      ...
   }
}


----Propriétés
Chargement des fichiers application.properties automatique
ces fichiers peuvent se placer à différents endroits, mais selon leur emplacement, ils n'ont pas la même priorité :
1. `file:./config/`   <- emplacement + prioritaire
2. `file:./`
3. `classpath:/config/`
4. `classpath:/`	<- emplacement - prioritaire


@ConfigurationProperties(prefix = "monappli")		permet de récupérer automatiquement les valeurs des propriétés et de les placer dans un bean sans avoir à utiliser @Autowired Environment ni @Value("${monappli.mapropriete}")
							ATTENTION : pour les classes Test, ne fonctionne que si la classe principale (contenant la méthode main) est annotée avec @EnableConfigurationProperties !

application.properties :
monappli.name=Mon nom
monappli.version=1.0.0
monappli.emails=contact@bigcorp.com, test@bigcorp.com
monappli.sousgroupe.measure-fixe=10
monappli.sousgroupe.measure-variable=20

							
@Component
@ConfigurationProperties(prefix = "monappli")
public class MonAppliProperties {
   private String name;
   private int version;
   private Set<String> emails;

   @NestedConfigurationProperty
   private MonSousGroupeDeProprietes sousgroupe;

   // getter et setter
}
		//@Nested identifie la classe automatiquement sans avoir besoin de l'annoter avec @Component
public class MonSousGroupeDeProprietes {
   private int measureFixe;
   private int measureVariable;
   
   //getter et setter
}


---------------------------------------------JPA

Dans le fichier build.gradle, ajout de la dépendence :

compile('org.springframework.boot:spring-boot-starter-data-jpa')	=> ajout de data-JPA
compile('org.springframework.boot:spring-boot-starter-web')		=> permet accés de la DB via navigateur web
compile('com.h2database:h2')						=> Embarquement d'une DB (ici : H2) dans le projet Gradle


Dans le fichier application.properties :

# Spring boot : datasource						=> config de la DB
spring.datasource.url=jdbc:h2:mem:bigcorp;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.platform=h2
spring.datasource.username=sa
spring.datasource.password=
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.sqlScriptEncoding=UTF-8

# Spring boot : H2 datasource						=> permet accés de la DB via navigateur web
spring.h2.console.enabled=true
spring.h2.console.path=/console

# Spring boot : JPA							=> permet la création automatique des tables à partir des annotations indiquées dans les @Entity
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
spring.jpa.ddl-auto=create-drop
spring.jpa.show_sql=true			=> affiche les requetes SQL dans la console


Dans le navigateur web : accés à la DB
http://localhost:8080/console


src/main/resources/schema.sql		fichier d'initialisation de la DB
					(utilie pour JDBC, mais facultatif si les tables sont auto-générées par JPA)

Exemple :
CREATE TABLE SITE(ID VARCHAR(255) PRIMARY KEY, NAME VARCHAR(255) NOT NULL);
CREATE TABLE CAPTOR(ID VARCHAR(255) PRIMARY KEY, NAME VARCHAR(255) NOT NULL,
SITE_ID VARCHAR(255) NOT NULL);
CREATE TABLE SITE_CAPTORS(SITE_ID VARCHAR(255) NOT NULL, CAPTOR_ID VARCHAR(255) NOT NULL);
ALTER TABLE CAPTOR ADD FOREIGN KEY (SITE_ID) REFERENCES SITE(ID);
ALTER TABLE SITE_CAPTORS ADD FOREIGN KEY (SITE_ID) REFERENCES SITE(ID);
ALTER TABLE SITE_CAPTORS ADD FOREIGN KEY (CAPTOR_ID) REFERENCES CAPTOR(ID);


src/main/resources/data.sql		fichier de remplissage de la DB

Exemple :
INSERT INTO SITE (ID, NAME, version) VALUES('site1', 'Bigcorp Lyon', 0);
INSERT INTO CAPTOR (DTYPE, ID, NAME, site_id, default_power_in_watt, version) VALUES('FIXED', 'c1', 'Eolienne', 'site1', 1000000, 0);
INSERT INTO CAPTOR (DTYPE, ID, NAME, site_id, min_power_in_watt, max_power_in_watt, version) VALUES('SIMULATED', 'c2', 'Laminoire à chaud', 'site1', 500000, 10000000, 0);
INSERT INTO MEASURE (ID, INSTANT, VALUE_IN_WATT, CAPTOR_ID, version) VALUES(-1, PARSEDATETIME ('09-08-18 11:00:00','dd-MM-yy hh:mm:ss', 'fr', 'UTC'), 1000000, 'c1', 0);
INSERT INTO MEASURE (ID, INSTANT, VALUE_IN_WATT, CAPTOR_ID, version) VALUES(-2, PARSEDATETIME ('09-08-18 11:01:00','dd-MM-yy hh:mm:ss', 'fr', 'UTC'), 1000124, 'c1', 0);
INSERT INTO MEASURE (ID, INSTANT, VALUE_IN_WATT, CAPTOR_ID, version) VALUES(-3, PARSEDATETIME ('09-08-18 11:02:00','dd-MM-yy hh:mm:ss', 'fr', 'UTC'), 1001234, 'c1', 0);


------Test
@RunWith(SpringRunner.class)
@DataJpaTest				=> a ajouter sur la classe Test pour utiliser JPA et le lien vers la DB 
@ComponentScan



-----------------------Spring Data JPA
JpaRepository< , >		interface dont doit hériter tous les DAO et permétant de ne pas avoir ré-écrire les méthodes principales (.findAll(), .save(), .remove(), ...)

public interface MonElementDao extends JpaRepository<MonElement, String> {
}

	Rq: le second type générique est celui de l'id de l'élément (Integer, Long, String, ...) et servira pour les méthodes : .findById(   )


personalisation de l'interface DAO :
	utilisation d'une interface CustomDao

public interface MonElementDao extends JpaRepository<MonElement, String>, MonElementCustomDao {
}

public interface MonElementCustomDao {
   public List<Captor> findBySiteId(String siteId);
}

@Repository
public class MonElementDaoImpl implements MonElementDao {

   @PersistenceContext
   private EntityManager em;

   @Override
   public List<Captor> findBySiteId(String siteId) {
      return em.createQuery("select c from Captor c inner join c.site s where s.id = :siteId", Captor.class)
         .setParameter("siteId", siteId)
         .getResultList();
   }
}

	ou modifiaction de l'interface MonElementDao elle-même en utilisant les conventions de JpaRepository :
public interface CaptorDao extends JpaRepository<Captor, String>, CaptorCustomDao {
   
   List<Captor> findBySiteId(String siteId);			=> findBy... requete retournant un élément ou liste d'élément
   List<Captor> findByNameAndSiteId(String name, String siteId);
   List<Captor> findByNameOrSiteId(String name, String siteId);
   List<Captor> findDistinctBySiteId(String siteId);
   List<Captor> countByName(String name, String siteId);


   @Query("select c from Captor c where c.name=:name")		=> @Query permet de définir une requete JPQL (Rq: ici on aurait pu utiliser la gestion automatique comme ci-dessus)
   Captor findByName(@Param("name") String name);
   
   @Modifying
   @Query("delete from Captor c where c.name = ?1")		=> @Modifying permet de modifier le comportment par défaut d'une requete automatique
   void deleteByName(String name);
}


@Version		active le controle optimiste de la concurrence
			cad, lorsque l'utilisateur manipule une entité, s'il essai de la persister mais que son numéro de version à changé entre temps, alors une exception OptimisticLockException est levée


@Entity
public class MonElement {
   @Id
   private String id = UUID.randomUUID().toString();

   @Version
   private Integer version;

   ...

   //constructeur vide

   //getter et setter
}



Annotations de validations	controle que les valeurs des champs avant la persistence de l'élément
@Null 		la valeur doit être nulle
@NotNull 	la valeur doit être non nulle
@AssertTrue 	la valeur doit être true
@AssertFalse 	la valeur doit être false
@DecimalMin	doit être supérieure à la décimale indiquée
@DecimalMax
@Digits		ne doit pas avoir plus de chiffre significatifs (av et ap la virgule compris)
@Size		défini les contraintes sur la taille d'une chaine de caractère
@Min		min pour un entier
@Max
@Pattern	vérifi la conformité d'une chaine avec une regex
@Future		la date doit être posterieure à la date courante
@Past
@Email		doit être un mail
@Valid		se place sur une propriété pour la validée




@Entity
public class Measure {
   @Id
   @GeneratedValue
   private Long id;

   @NotNull
   @Past
   private Instant instant;

   @Min(0)
   @NotNull
   private Integer minPower;

   @Min(0)
   @NotNull
   private Integer maxPower;

   @Size(min = 15, max = 150)
   @Email
   private String email;

   @AssertTrue(message = "minPower should be less than maxPower")
   public boolean isValid() {
       return this.minPower <= this.maxPower;
   }

   // ...
}


Exemple de classes de Test avec les annotations de validation :
@Test
public void createShouldThrowExceptionWhenNameIsNull() {
   Assertions.assertThatThrownBy(() -> {
         measureDao.save(new Measure(null, null));
         entityManager.flush();
         })
      .isExactlyInstanceOf(javax.validation.ConstraintViolationException.class)
      .hasMessageContaining("must not be null");
}

@Test
public void createSimulatedCaptorShouldThrowExceptionWhenMinMaxAreInvalid() {
   Assertions.assertThatThrownBy(() -> {
         measureDao.save(new Measure(50, 25));
         entityManager.flush();
         })
      .isExactlyInstanceOf(javax.validation.ConstraintViolationException.class)
      .hasMessageContaining("minPower should be less than maxPower");
}

@Test
public void createShouldThrowExceptionWhenNameSizeIsInvalid() {
   Assertions.assertThatThrownBy(() -> {
         measureDao.save(new Measure("mail@sfr.fr"));
         entityManager.flush();
         })
      .isExactlyInstanceOf(javax.validation.ConstraintViolationException.class)
      .hasMessageContaining("size must be between 15 and 150");
}


----------------------------------------------MVC
Dans build.gradle
dependencies {
   implementation('org.springframework.boot:spring-boot-starter-web')
}
		=> application autonome, cad qui embarque son propre serveur auto configuré


resources web :
src/main/resources
   /static
	/css	=> fichiers CSS
	/img	=> fichiers images
	index.html
   /template	=> vues partielles (.jsp, .mustache, ...)


@Controller		déclare un bean Spring de type Controller
			equiv à une servlet, mappage via les annotations, redirection vers le modelle et la vue par ModelAndVue

@Controler
@RequestMapping("/suiteUrlA")		=> gere tous les URL https://monAppli/suiteUrlA/...
@Transactional				=> indispensable si entités liées à DB
public class MonController {
   
   @Autowired
   MonElementDao monElementDao;

   @RequestMapping(path = "/suiteUrlB", method = RequestMethod.GET)
   public ModelAndView create() {
      return new ModelAndView("maPage").addObject("monEntity", new MonEntity());
   }

   @GetMapping("/suiteUrlB/{entityId}")
   public ModelAndView findById(@PathVariable String monId) {
      MonElement monEntity = monEntityDao.findById(entityId).orElseThrow(IllegalArgumentException::new);
      return new ModelAndView("maPageDeMonEntity").addObject("monEntity", monEntity);
   }

   @PostMapping(consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)
   public ModelAndView save(MonEntity monEntity) {		=> génération automatique de l'entité via les paramètres du formulaire si ceux-ci respectent les noms des champs de l'entité
      entityDao.save(entity);
      return new ModelAndView("monAutrePage");
    }

   @PostMapping("/suiteUrlB/delete?entityId=monId")
   public ModelAndView delete(@RequestParam String entityId) {
      Entity entity = entityDao.findById(entityId).orElseThrow(IllegalArgumentException::new);
      entityDao.delete(entity);
      return new ModelAndView("monAutrePage");
   }
}


options des annotations :

   consumes	défini le type de données acceptées en entrées	@PostMapping(consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE)
   produces	défini le type de données acceptées en sortie	@GetMapping(produces = MediaType.APPLICATION_XML_VALUE)
   headers	filtre le mapping en fonction des attributs dans le head de la requete html
   params	filtre le mapping en fonction des paramètres de l'URL
   

objet récupérable en parametre dans les méthodes annotées @XxxMaping(   ) :
   Model	accés au modele (map clé/valeur)
   Locale	objet contenant les infos régionales de l'utilisateur envoyés par http
   HttpSession	accés à l'ojet session
   HttpServletRequest	accés à l'objet request et info valides seulement le temps de la requete



DTO = Data Transfer Object (objet de transfert de données)


----Mustache

Dans build.gradle
dependencies {
   implementation('org.springframework.boot:spring-boot-starter-mustache')
}

		= utilisation des fichier .mustache (équiv de .jsp en plus basique mais plus performant)

<header>
   {{>partial-header}}		=> ajout de la page "partial-header.mustache" à la page
</header>

<section>
   {{#items}}			=> si la liste existe, alors pour chaque item
      Name: {{name}}		=> item.name
      Price: {{price}}
      {{#features}}
         Feature: {{description}}
      {{/features}}
   {{/items}}
   {{^items}}			=> si la liste items n'existe pas
      Pas d'item{
   {/items}}
</section>

<section>
   {{! value contient '<b>Hello</b>'}} 	=>commentaire
   {{value}}				=>caractères HTML échappées pour éviter l'injection (ex : &lt;b>Hellob&gt)
   {{{value}}}				=>caractère HTML non échapés (ex : <b>Hello</b>)
</section>


-------REST = REpresentational State Transfer

API REST ou API Web	au lieu de renvoyer des données sous forme de pages web interprétable par le navigateur, on peut exposer les données de notre application via l'API REST incluse dans Spring. Les données (toujours demandées vias des URL) sont transmisent cette fois au format JSON pour être utilisé par une autre appli, par du JavaScript, ...
			Pour cela, on ne passe plus par les Controller, mais par des RestController qui ne renvérons pas des ModelAndView, mais des objets DTO contenant les données qui seront automatiquements transcrites en JSON par Spring avant d'être renvoyées au client

Exemple :

@RestController
@RequestMapping("/sites/{siteId}/captors")
@Transactional
public class RestCaptorController {

   @Autowired
   private CaptorDao captorDao;

   private List<CaptorDto> toDtos(List<Captor> captors){
      return captors.stream().map(this::toDto).collect(Collectors.toList());
   }

   @GetMapping
   public List<CaptorDto> findAll(@PathVariable String siteId) {
      return toDtos(captorDao.findBySiteId(siteId));
   }

   @GetMapping("/{id}")
   public CaptorDto findById(@PathVariable String siteId, @PathVariable String id) {
      Captor captor = captorDao.findById(id).orElseThrow(NotFoundException::new);
      return CaptorDto.toDto(captor);
   }

   @PostMapping
   public CaptorDto save(@PathVariable String siteId, CaptorDto captorDto) {
      Site site = siteDao.findById(siteId).orElseThrow(NotFoundException::new);
      Captor captor = captorDto.toCaptor(site);
      return CaptorDto.toDto(captorDao.save(captor));
   }

   @PutMapping("/{id}")
   public void update(@PathVariable String siteId, @PathVariable String id, CaptorDto captorDto) {
      Captor captorToUpdate = captorDao.findById(id).orElseThrow(NotFoundException::new);
      captorToUpdate.setName(captorDto.getName());
      captorDao.save(captorToUpdate);
   }


   @DeleteMapping("/{id}")
   public void delete(@PathVariable String siteId, @PathVariable String id) {
      measureDao.deleteByCaptorId(id);
      captorDao.deleteById(id);
   }
}



A l'inverse, si on veut utiliser l'API REST d'une autre application via une URL, on créé une classe Service qui va utiliser RestTemplate :


@Service
public class MonService {
   private final RestTemplate restTemplate;

   public MonService(RestTemplateBuilder builder) {
      this.restTemplate = builder.setConnectTimeout(1000).build();		=> interruption de la demande si délai supérieur à 1s
   }

   @Override
   public UserDto readMeasures(String userId) {
      UriComponentsBuilder builder = UriComponentsBuilder
         .fromUriString("http://urlappli/users/{user_id}")		=> url de l'appli REST et contenent la demande
         .build(userId);
      return this.restTemplate.getForObject(builder.toUriString(), UserDto.class);	=> appel du service en précisant le type d'objet qui servira pour récupérer les infos après lecture des données JSON
   }
}


Exemple avec une liste d'objet et une url avec des paramètres :

@Service
public class SimulatedMeasureService implements MeasureService<SimulatedCaptor> {
   private RestTemplate restTemplate;
   
   public SimulatedMeasureService(RestTemplateBuilder builder) {
      this.restTemplate = builder.setConnectTimeout(1000).build();
   }

   public List<Measure> readMeasures(SimulatedCaptor captor, Instant start, Instant end, MeasureStep step) {
      checkReadMeasuresAgrs(captor, start, end, step);
      UriComponentsBuilder builder = UriComponentsBuilder
         .fromHttpUrl("http://localhost:8090/measures")
         .path("")
         .queryParam("start", start)
         .queryParam("end", end)
         .queryParam("min", captor.getMinPowerInWatt())
         .queryParam("max", captor.getMaxPowerInWatt())
         .queryParam("step", step.getDurationInSecondes());

      Measure[] measures = this.restTemplate.getForObject(builder.toUriString(), Measure[].class);

      return Arrays.asList(measures);
   }
}


------Exception

src/main/resources/templates/error		emplacement des pages d'erreurs personnalisées

404.mustache					page appelée automatiquement lors de la levée d'une erreur 404

server.error.include-stacktrace=always		à ajouter dans application.properties pour permettre un affichage plus complet des messages d'erreurs dans les pages

						accés au valeurs des champs de l'erreur
<h1>{{status}} : {{error}}</h1>
   <ul>
      <li>Heure : {{timestamp}}</li>
      <li>Path : {{path}}</li>
      <li>Message : {{message}}</li>
   </ul>
   <code>{{trace}}</code>


@ControllerAdvice				Controller permettant de rediriger une exception vers une page d'erreur/fournir une erreur au client REST
						Rq: par défaut, une exception est transformée en erreur 500 (= erreur du serveur)

@ControllerAdvice
public class ExceptionController {

   //Redirection vers une page d'erreur
   @ExceptionHandler
   public ModelAndView handle(NotFoundException e){
      ModelAndView mv = new ModelAndView("/error/404")
         .addObject("status", 404)
         .addObject("error", "Not found exception")
         .addObject("trace", e.getStackTrace().toString())
         .addObject("timestamp", new Date())
         .addObject("message", e.getMessage());
      mv.setStatus(HttpStatus.NOT_FOUND);
      return mv;
   }

   //réponse d'erreur à la demande REST
   @ExceptionHandler(NotFoundException.class)
   public ResponseEntity<ErrorDto> handle(NotFoundException e){
      return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorDto(e.getMessage()));
   }

   private class ErrorDto{
      private final String message;
      private final Date date = new Date();
      public ErrorDto(String message) {
         this.message = message;
      }
      public String getMessage() {
         return message;
      }
      public Date getDate() {
         return date;
      }
   }
}


-------------------------------------------Security








