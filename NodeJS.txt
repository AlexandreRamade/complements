Principe :
NodeJS permet d'utiliser JavaScript en dehors d'un navigateur Web.
Comme Chrome, il se base sur V8 pour interpréter et optimiser le code JS.

NPM est le gestionnaire de projet JavaScript (équiv de Maven et Gradle pour Java)


Instalation :
GitHub de Nodist : https://github.com/nullivex/nodist
Nodist permet d'instaler plusieurs versions de Node.JS sur une même machine et de selectionner la version à utiliser.
Pour instaler Nodist et NodeJS : https://github.com/nullivex/nodist/releases
	> télécharger et exécuter .exe
	> "node -v" et "npm -v" en ligne de commande pour vérifier que cela a bien fonctionné et que le variable Path a été MàJ



NPM = Node Package Manager

ligne de commande
node application.js	=> lance l'appli
npm init -y		=> initialise le projet (création du fichier package.json)
npm install monModule --save	=> télécharge la dépendance en local, cad dans le dossier node_modules du projet)
npm install monModule --save-dev	=> télécharge la dépendance en local en mode développeur
npm install -g monModule	=> instaler la dépendance en global, cad dans Node et accessible par tous les projets
npm uninstall -g monModule	=> désinstalation de la dépendance globale




package.json		=> fichier de config (equi à POM.xml de Maven ou build.gradle de gradle) qui defini 
				- nom (obligatoire)
				- version (obligatoire)
				- dépendances
				- racourcits en ligne de commandes ("script": {})



dossier node_modules	contient toutes les dépendances liées au projet et chargé par npm
			ATTENTION : à ne pas chargé sur GitHub


lors du lancement d'un fichier .js, Node place le contenu dans une fonction afin de préserver le global space name et de mettre à disposition 5 éléments accéssibles partout dans l'appli
(function (exports, require, module, __filename, __dirname){
   contenu du fichier.js original
});

exports		=> ref à module.exports
require		=> permet de charger les modules (fichiers .js ou dépendances incluses dans node_modules)
module		=> ref au module courant pour mettre à disposition l'élément module.export qui permet d'exporter des objets du fichier courant
__filename	=> ref au fichier .js lui-même
__dirname	=> ref au dossier courant lui-même


var monObjet = require('monmodule')		importe le module contenu dans le dossier de dépendances node_modules
var monObjet = require('./monFichier.js')	importe les éléments déclarés module.exports = ... dans le fichier dans le même dossier
var monObjet = require('../monFichier.js')	importe les éléments déclarés module.exports = ... dans le fichier dans le dossier parent



	fichierA.js
module.exports = monObjet;			=> rend l'objet monObjet accéssible (via un require('fichierA')) depuis un autre fichier JavaScript

	fichierB.js
var monObjet = require('./fichierA');		=> récupération de monObjet dans un autre fichier (ici dans le même dossier)




------------Dépendances

npm install lodash --save	=> pratique

const _ = require('lodash');

function sayHello (name) {
   if (_.isString(name) && !_.isEmpty(name)) {
      console.log('Hello ' + name);
   }
}





---------Tests unitaires
Mocha gère les tests unitaires (equiv de JUnit en Java)
ajouter la dépendance mocha au projet
créer un dossier test
les fichiers sont només : monFichier.spec.js

mpn node_modules/.bin/mocha		=> lance les tests
dans package.json
"scripts": {
   "test": "mocha"		=> lance les tests avec "mpn mocha"


npm install chai --save-dev		=> permet d'ajouter des fonctionalités aux tests de base


var expect = require('chai').expect;

describe('Math.addition', function() {
   describe('#without arguments', function() {
      it('should return 0 when have no arguments', function() {
         expect(function() {
            math.addition()}).to.not.throw();
         expect(math.addition()).to.equal(0);
      });
   });

   describe('#agrgument is not a number', function() {
      it('should ignore argument that is not a number', function() {
         expect(function() {
            math.addition(2, 4, 'notNumber')}).to.not.throw();
         expect(math.addition(2, 4, 'notNumber')).to.equal(6);
      });
   });

});





____________________________ ES6 + ____________________________________

var	pas utilisé
cont	= constante, objet non mutable cad référence mémoire qui ne change pas, mais peut ajouter/suppr les propriétés dynamque comme avec une var
let	= variable	for(let i = 0; i < 10; i++) {}

`  `	equiv de '   ' pouvant contenir des EL sans avoir besoin de concaténer
${   }


(e => e + 1)	Arrow function : equiv des lambda en Java : fct annonyme plus facile et claire, NE CREE PAS DE NOUVEAU SCOPE !
((e, f) => e + f)
(e => ({prop1: val1, prop2: val2}))	retourne un objet
(e => {
   instruction(s);
   return e;
})


...monObjet				= tableau

function f (x, y = 2, z = 3) {		paramètres de fonctions avec des valeurs par défauts si non précisées lors de l'appel de la fct
   return x + y + z;
}

function f (x, y, ...arr) {		un tableau contenant tous les paramètres au dela du second
   return (x + y) * arr.length;
}


var params = ['hello', true, 7];
var other = [1, 2, ...params];		clone les items du tableau params dans le tableau other
	=> other = [1, 2, 'hello', true, 7]


var monObjetA {
   prop1: val1,
   prop2: val2
}

var monObjetB {				clone les noms et valeurs des propriétés de l'objet A dans l'objet B
   ...monObjetA,
   prop3: val3
}



					equiv de monObjet = {x = x, y = y}
var x = 1;
var y = 2;

monObjet = {
   x,
   y
}



					définir un nom de variable de manière dynamique
function monCalcul(x, y) {
   return x + y;
}

let monObjet = {		
   prop1: val1,
   ['prop' + monCalcul(1, 1)]: val2
}


					plus besoin de préciser maFonction: function(x, y) {
monObjet = {
   maFonction(x, y) {
      instruction(s);
   }




					Destructuring
var {prop1, prop5 = 'valDefaut', prop6} = maFctQuiRetourneUnObj();		ne récupére que les valeurs des props qui m'intéressent de l'objet
										(si prop5 n'est pas trouvée dans l'objet, elle prendra la valeur 'valDefaut' par défaut)

var {prop1: a, prop5: b, prop6: c} = maFctQuiRetourneUnObj();			récupère les valeur et les place dans des constantes pouvant être utilisées directement
if(a > 5) {
   ...
}


function([obj1, obj2]) {
   console.log(obj1, obj2);
}

function({obj1, obj2}) {
   console.log(obj1, obj2);
}



							export
export function maFonction() {};
export cst maConstante = 3;
export monObjet;
							import
import * as maVariable from 'chemin/monFichier'
import {monObjet, maFonction} from 'chemin/monFichier'




							constructeur d'un objet
class MonObjet {
   constructor (id, x, y) {
      this.id = id;
      this.move(x, y);
   }
   move (x, y) {
      this.x = x;
      this.y = y;
   }
}

class MonObjetB extends MonObjet {
   constructor (id, x, y, z) {
      super(id, x, y);
      this.z = z;
   }
}



------------- API Promises		=> permet les traitements asynchrones

Promises = objet qui représente une valeur qui peut être disponible maintenant ou plus tard, ou jamais.

on y attache des callback qui sont appeles en fonction du succés ou de l'échec de la réponse
Etats des promises :
 - pending = en attente
 - fulfilled = tenue, succés
 - rejected = rompue, erreur
 - settled = acquitée, traitement terminé

	=> 3 chemins possibles : pending / pending->fulfilled->settled / pendig->rejected->settled




					exemple général de déclaration d'une Promise
const maPromise = new Promise( function(resolve, reject) {
   if(true == true) {
      resolve(monObjetResult);
   } else {
      reject();
   }
});

maPromise
   .then((monObjetResult) => {instruction(s) en cas de succés})	=> définit la fonction resolve
   .catch(() => {instruction(s) en cas d'échec});	=> définit la fonction reject



					promises en concurences, si l'une des 3 est rejected, alors on passe dans .catch
					Rq: on ne peut dans ce cas pas passer en argument de la promise suivante le return de la promise précédente
Promise.all([
   faireQqc(),
   faireAutreChose(),
   faireUnTroisiemeTruc()
])
   .then(()=>{})
   .catch(e=>{});



					Avec async/await
					idem, mais en passant les résultats des précédentes dans les suivantes
async function toto() {
   try {
      let result = await faireQqc();
      let newResult = await faireQqcAutre(result);
      let finalResult = await faireUnTroisiemeTruc(newResult);
      return finalResult;
   } catch(error) {
      failureCallback(error);
   }
}

toto().then(finalResult => console.log(finalResult));		et récupération du résultat à l'extérieur de la fonction async





					lancement de plusieurs callback en même temps et retourne la réponse quand les résultats sont tous récupérés
async function add1(x) {
   var a = resolveAfter2Seconds(20);
   var b = resolveAfter2Seconds(30);
   return x + await a + await b;
}

add1(10).then(v => {console.log(v);}); // affiche 60 après 2 secondes.






-----Fonction Générator
voir : https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Instructions/function*

				fonctionne comme le mode debug
function* monGenerator(i) {
   instruction(s);
   yield i + 1;
   instruction(s);
   yield i + 10;
   return result;
}

var gen = monGenerator(10);	=> joue la fonction jusqu'au premier yield (gen.next().value() retourne 11)
gen.next();			=> joue la fonction jusqu'au yield suivant (gen.next().value() retourne 20)
gen.next();			=> joue la fonction jusqu'à la fin (gen.next().value() retourne result)






