-- Router

permet la navigation dans l'appli tout en actualisant l'URL dans le navigateur sans appel serveur, navigation prise en charge par framework JavaScript
1 URL = 1 route = 1 état de l'appli 

				config dans app.modules.ts
imports: [
    HttpClientModule,
    ...
  ],






---------- Forms

				config dans app.modules.ts
imports: [
   FormsModule,
   ...
],



2 approches possible :

	*Coté template

	récupération des données lors du clic sur le bouton submit
<form (ngSubmit)="handleSubmit(loginForm.value)" #nginForm="ngForm">
   <input type="text" name="email" ngModel />
   <input type="submit" value="Valider" />
</form>

	récupération des données dynamiquement en même temps qu'elles sont entrées par l'utilisateur
	(lors du clic sur submit, les données sont déjà à jour dans l'objet user coté TS)
<form (ngSubmit)="handleSubmit()">
   <input type="text" name="email" [(ngModel)]="user.email" require email #emailModel="ngModel"/>
   <div *ngIf="emailTemplate.dirty && emailTemplate.hasError('email')">
      Le champ email n'est pas valide
   </div>
   <div *ngIf="emailTemplate.dirty && emailTemplate.hasError('required')">
      Le champ email est requis
   </div>
   <input type="submit" value="Valider" [disabled]="userFormTemplate.invalid" />
</form>



	*Coté code

				config dans app.modules.ts
imports: [
   FormsModule,
   ReactiveFormsModule
   ...
],


FromControl
			fournit des méthodes permettant de controler la valeur du champ

value : la valeur du champ.
valueChanges : un Observable qui émet à chaque modification du champ.
valid : le champ est-il valide ?
invalid : le champ est-il invalide ?
errors : Récupération des erreurs du champ
dirty : = false jusqu’à ce que l’utilisateur modifie la valeur du champ.
pristine : = true jusqu’à ce que l’utilisateur modifie la valeur du champ
touched : = false tant que l’utilisateur n’a pas pris le focus sur le champ.
untouched : = true tant que l’utilisateur n’a pas pris le focus sur le champ.
hasError: fonction qui permet de connaitre si le champ a une erreur donnée. Prend le nom de l’erreur en paramètre



FormGroup
			= ensemble de FromControl
			mêmes méthodes mais valables pour le groupe de champs entier
get	=> récupére un FormControl par son nom


								////////////////////code couvrant jusqu'aux style !
<form (ngSubmit)="handleSubmit()" [formGroup]="userForm">
   <div>
      <label>Email:</label>
      <input type="text" formControlName="email" class="input-angular" />		=> voir style
      <div *ngIf="emailCtrl.dirty && emailCtrl.hasError('email')">Le champ email est invalide !</div>
      <div *ngIf="emailCtrl.dirty && emailCtrl.hasError('required')">Le champ email est requis !</div>
   </div>
   <input type="submit" value="Login" [disabled]="userForm.invalid"/>
</form>

@...
export class CodeFormComponent {

  emailCtrl: FormControl;
  passwordCtrl: FormControl;
  userForm: FormGroup;

  constructor(fb: FormBuilder) {

    //Création des controles
    this.emailCtrl = fb.control('', [Validators.email, Validators.required]);
    this.passwordCtrl= fb.control('', [Validators.required, isPrefixValidator]);	=> voir validator personnalisé

    //Création du groupe
    this.userForm = fb.group({
      email: this.emailCtrl,
      password: this.passwordCtrl
    });
  }

  handleClear() {
    this.emailCtrl.setValue('');
    this.passwordCtrl.setValue('');
  }

  handleSubmit() {
    console.log(this.userForm.value);
  }
}




Validator
			permet de valider un champs, utilisable dans les 2 techniques (template et code)

Validators.required
Validators.minLength(nb)
Validators.maxLength(nb)
Validators.email()
Validators.pattern(maRegEx)
Validators.min(nb)
Validators.max(nb)


			validator personnalisé

import { FormControl } from '@angular/forms';
import _ from 'lodash';

export const PREFIX: string = 'nk';
export const PREFIX_SEPARATOR: string = '-';

/**
 * La valeur du champ commence-t-elle par nk-
 * @param{FormControl} control
 * @returns {{isPrefix: boolean}}
 */
export function isPrefixValidator(control: FormControl) {
    const prefix = _.split(control.value, PREFIX_SEPARATOR, 1);
    console.log('Préfixe :', prefix[0]);
    return (_.isArray(prefix)  && PREFIX === prefix[0]) ? null : { isPrefix: true};	=> ici, l'erreur levée sera "isPrefix"
}


			validator personnalisé avec paramètre

import { FormControl } from '@angular/forms';
import _ from 'lodash';

export const PREFIX_SEPARATOR: string = '-';

/**
 * La valeur du champ commence-t-elle par le préfixe attendu
 * @param{expectedPrefix} prefixe attendu
 * @param{FormControl} control
 * @returns {{isPrefix: boolean}}
 */
export function parametrableValidator(expectedPrefix) {
    return function (control: FormControl) {
        const prefix = _.split(control.value, PREFIX_SEPARATOR, 1);
        return (_.isArray(prefix)  && prefix[0] === expectedPrefix) ? null : { isPrefix: true};
    }
}





Style
			changer le style d'un champs selon sa validité
			FormControl ajoute une classe sur le champ à chaque changement de validité

valid => ng-valid
invalid => ng-invalid
dirty => ng-dirty
pristine => ng-pristine
touched => ng-touched
untouched => ng-untouched


class="input-angular">		sur l'élément HTML


				code CSS
.input-angular {
    background-color: rgba(205, 208, 214, 0.56);
    color: #3e3c3c;
}

.input-angular.ng-invalid.ng-dirty {	=> si possede les 3 classes
    border: 2px red solid;
    border-radius: 2px;
}

.input-angular.ng-valid {
    border: 2px green solid;
    border-radius: 2px;
}








-------- CSS via framework (ex: Bootstrap)
utilisation d'une librairie réécrite pour Angular (ex: Angular powered Bootstrap)
instaler la librairie via npm install
l'importer les éléments nécéssaire dans le composant en question
@Component ({
   ...
   imports: [...],
   ...
})






























____________________Programation réative_____________________________________
site ReactiveX		permet de créer un projet en prog réactive pour plusieurs langages

RxJS	en ES6

But vis-à-vis des fonctions : avoir uniquement des Pures Fonctions, cad des fonctions qui ne dépendent pas d'un paramètre/argument en dehors de leur corps
=> faible couplage, plus facile d'entretient, plus de lisibilité, ...


							création d'un suscriber
							Rq: hot observable qui n'a pas de complite() qui le termine
								cold observable a un complite() qui le termine
							Rq: par convention on sufixe une variable observable avec $
const observable$ = new Observable(suscriber => {
   suscriber.next(1);
   suscriber.next(2);
   setTimout(() => {
      suscriber.next(3);
      suscriber.complite();
   }, 1000);
}

						s'abonne au éléments retournés par l'observable et leur applique un traitement
						ATTENTION : lorsque le traitement est terminé, il faut se désinscrire pour ne pas avoir de fuite de mémoire !
	
observable.subscribe({
  next(x) { console.log('got value ' + x); },
  error(err) { console.error('something wrong occurred: ' + err); },
  complete() { console.log('done'); }
});



Exemple d'un hot observable :
import { fromEvent } from 'rxjs';		=> fromEvent permet la création d'un observable

monObservable$:Observable = fromEvent(document, 'click').suscribe(() => console.log('Clicked on the page');



	pipe(   )		permet de chainer des opérations à l'intérieur avant l'appel du suscribe

import { fromEvent } from 'rxjs';
import { scan } from 'rxjs/operators';

monObservable$:Observable = fromEvent(document, 'click')
   .pipe(scan(count => count +1, 0))
   .suscribe(count => console.log(`Clicked ${count} fois`));








 






















